package handlers

import (
	"encoding/json"
	"net/http"
	"strconv"

	"github.com/lcalzada-xor/wmap/internal/core/domain"
	"github.com/lcalzada-xor/wmap/internal/core/services/security"
)

type VulnerabilityHandler struct {
	service *security.VulnerabilityPersistenceService
}

func NewVulnerabilityHandler(service *security.VulnerabilityPersistenceService) *VulnerabilityHandler {
	return &VulnerabilityHandler{
		service: service,
	}
}

// GetVulnerabilities returns a list of vulnerabilities.
// Query Params: device_mac, status (active, ignored, fixed), min_severity
func (h *VulnerabilityHandler) GetVulnerabilities(w http.ResponseWriter, r *http.Request) {
	mac := r.URL.Query().Get("device_mac")
	statusStr := r.URL.Query().Get("status")
	severityStr := r.URL.Query().Get("min_severity")

	var status *domain.VulnerabilityStatus
	if statusStr != "" {
		s := domain.VulnerabilityStatus(statusStr)
		status = &s
	}

	minSeverity := 0
	if severityStr != "" {
		minSeverity, _ = strconv.Atoi(severityStr)
	}

	filter := domain.VulnerabilityFilter{
		DeviceMAC:   mac,
		Status:      status,
		MinSeverity: minSeverity,
	}

	vulns, err := h.service.GetVulnerabilities(filter)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(vulns)
}

// UpdateStatus updates the status of a vulnerability.
// PUT /api/vulnerabilities/{id}/status
// Body: { "status": "ignored" }
func (h *VulnerabilityHandler) UpdateStatus(w http.ResponseWriter, r *http.Request) {
	id := r.PathValue("id")
	if id == "" {
		http.Error(w, "ID required", http.StatusBadRequest)
		return
	}

	var req struct {
		Status string `json:"status"`
		Notes  string `json:"notes"`
	}
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid body", http.StatusBadRequest)
		return
	}

	if req.Status == "" {
		http.Error(w, "Status required", http.StatusBadRequest)
		return
	}

	status := domain.VulnerabilityStatus(req.Status)
	// Validate status
	if status != domain.VulnStatusActive && status != domain.VulnStatusIgnored && status != domain.VulnStatusFixed {
		http.Error(w, "Invalid status", http.StatusBadRequest)
		return
	}

	if err := h.service.UpdateStatus(id, status, req.Notes); err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusOK)
}

// GetVulnerability returns a single vulnerability by ID
func (h *VulnerabilityHandler) GetVulnerability(w http.ResponseWriter, r *http.Request) {
	id := r.PathValue("id")
	if id == "" {
		http.Error(w, "ID required", http.StatusBadRequest)
		return
	}

	// Get all vulnerabilities and filter by ID
	// This is not optimal but works with current service interface
	filter := domain.VulnerabilityFilter{}
	vulns, err := h.service.GetVulnerabilities(filter)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	for _, vuln := range vulns {
		if vuln.ID == id {
			w.Header().Set("Content-Type", "application/json")
			json.NewEncoder(w).Encode(vuln)
			return
		}
	}

	http.Error(w, "Vulnerability not found", http.StatusNotFound)
}

// GetVulnerabilityStats returns statistics about vulnerabilities
func (h *VulnerabilityHandler) GetVulnerabilityStats(w http.ResponseWriter, r *http.Request) {
	filter := domain.VulnerabilityFilter{}
	vulns, err := h.service.GetVulnerabilities(filter)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	stats := struct {
		Total         int            `json:"total"`
		BySeverity    map[string]int `json:"by_severity"`
		ByStatus      map[string]int `json:"by_status"`
		ByCategory    map[string]int `json:"by_category"`
		CriticalCount int            `json:"critical_count"`
		HighCount     int            `json:"high_count"`
		MediumCount   int            `json:"medium_count"`
		LowCount      int            `json:"low_count"`
		ActiveCount   int            `json:"active_count"`
		IgnoredCount  int            `json:"ignored_count"`
		FixedCount    int            `json:"fixed_count"`
	}{
		Total:      len(vulns),
		BySeverity: make(map[string]int),
		ByStatus:   make(map[string]int),
		ByCategory: make(map[string]int),
	}

	for _, vuln := range vulns {
		// By severity
		severityStr := vuln.Severity.String()
		stats.BySeverity[severityStr]++

		// Counters
		switch vuln.Severity {
		case domain.VulnSeverityCritical:
			stats.CriticalCount++
		case domain.VulnSeverityHigh:
			stats.HighCount++
		case domain.VulnSeverityMedium:
			stats.MediumCount++
		case domain.VulnSeverityLow:
			stats.LowCount++
		}

		// By status
		stats.ByStatus[string(vuln.Status)]++
		switch vuln.Status {
		case domain.VulnStatusActive:
			stats.ActiveCount++
		case domain.VulnStatusIgnored:
			stats.IgnoredCount++
		case domain.VulnStatusFixed:
			stats.FixedCount++
		}

		// By category
		if len(vuln.Evidence) > 0 {
			// Category is stored in the tag, not directly in record
			// We'll use a simple heuristic based on vulnerability name
			category := "other"
			if vuln.Name == "WEP" || vuln.Name == "TKIP" || vuln.Name == "KRACK" {
				category = "protocol"
			} else if vuln.Name == "WPS-PIXIE" || vuln.Name == "WPS-ENABLED" {
				category = "configuration"
			}
			stats.ByCategory[category]++
		}
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(stats)
}
