package security

import (
	"fmt"
	"strings"
	"time"

	"github.com/lcalzada-xor/wmap/internal/core/domain"
	"github.com/lcalzada-xor/wmap/internal/core/ports"
)

// VulnerabilityDetector analyzes devices for security vulnerabilities (passive only)
type VulnerabilityDetector struct {
	registry ports.DeviceRegistry
}

// NewVulnerabilityDetector creates a new vulnerability detector.
func NewVulnerabilityDetector(registry ports.DeviceRegistry) *VulnerabilityDetector {
	return &VulnerabilityDetector{
		registry: registry,
	}
}

// DetectVulnerabilities performs passive vulnerability analysis on a device.
func (vd *VulnerabilityDetector) DetectVulnerabilities(device *domain.Device) []domain.VulnerabilityTag {
	tags := []domain.VulnerabilityTag{}

	// 1. Protocol-based detection
	tags = append(tags, vd.detectProtocolVulnerabilities(device)...)

	// 2. Configuration-based detection
	tags = append(tags, vd.detectConfigurationVulnerabilities(device)...)

	return tags
}

func (vd *VulnerabilityDetector) detectProtocolVulnerabilities(device *domain.Device) []domain.VulnerabilityTag {
	tags := []domain.VulnerabilityTag{}

	// WEP Detection (Critical)
	if strings.Contains(strings.ToUpper(device.Security), "WEP") {
		tags = append(tags, domain.VulnerabilityTag{
			Name:        "WEP",
			Severity:    domain.VulnSeverityCritical,
			Confidence:  domain.ConfidenceConfirmed,
			Evidence:    []string{"WEP encryption detected in beacon/probe"},
			DetectedAt:  time.Now(),
			Category:    "protocol",
			Description: "WEP is fundamentally broken and can be cracked in minutes",
			Mitigation:  "Upgrade to WPA2-PSK (AES) or WPA3",
		})
	}

	// Additional protocol-specific logic
	if device.RSNInfo != nil {
		// 1. TKIP Detection (High - vulnerable to KRACK)
		if containsString(device.RSNInfo.PairwiseCiphers, "TKIP") {
			tags = append(tags, domain.VulnerabilityTag{
				Name:        "TKIP",
				Severity:    domain.VulnSeverityHigh,
				Confidence:  domain.ConfidenceConfirmed,
				Evidence:    []string{"TKIP cipher detected in RSN IE"},
				DetectedAt:  time.Now(),
				Category:    "protocol",
				Description: "TKIP is deprecated and vulnerable to key reinstallation attacks",
				Mitigation:  "Use CCMP (AES) cipher only",
			})
		}

		// 2. WPA2 without PMF (Medium - vulnerable to deauth attacks)
		if strings.Contains(device.Security, "WPA2") && !device.RSNInfo.Capabilities.MFPRequired {
			tags = append(tags, domain.VulnerabilityTag{
				Name:        "NO-PMF",
				Severity:    domain.VulnSeverityMedium,
				Confidence:  domain.ConfidenceConfirmed,
				Evidence:    []string{"PMF not required in RSN capabilities"},
				DetectedAt:  time.Now(),
				Category:    "configuration",
				Description: "Management frames unprotected - vulnerable to deauth attacks",
				Mitigation:  "Enable 802.11w (PMF) on AP",
			})
		}

		// 3. KRACK inference (Medium confidence)
		if strings.Contains(device.Security, "WPA2") {
			tags = append(tags, domain.VulnerabilityTag{
				Name:        "KRACK",
				Severity:    domain.VulnSeverityMedium,
				Confidence:  domain.ConfidenceMedium,
				Evidence:    []string{"WPA2 protocol detected", "No way to verify patch level passively"},
				DetectedAt:  time.Now(),
				Category:    "protocol",
				Description: "WPA2 vulnerable to key reinstallation if not patched",
				Mitigation:  "Ensure firmware is updated (post-2017)",
			})
		}

		// 4. WPA3 Transition Mode
		if device.Security == "WPA3" {
			hasPSK := containsString(device.RSNInfo.AKMSuites, "PSK")
			hasSAE := containsString(device.RSNInfo.AKMSuites, "SAE")
			if hasPSK && hasSAE {
				tags = append(tags, domain.VulnerabilityTag{
					Name:        "WPA3-TRANSITION",
					Severity:    domain.VulnSeverityLow,
					Confidence:  domain.ConfidenceConfirmed,
					Evidence:    []string{"Both PSK and SAE AKMs advertised"},
					DetectedAt:  time.Now(),
					Category:    "configuration",
					Description: "WPA3 transition mode allows downgrade to WPA2",
					Mitigation:  "Use WPA3-only mode when all clients support it",
				})
			}

			// Dragonblood inference
			tags = append(tags, domain.VulnerabilityTag{
				Name:        "DRAGONBLOOD",
				Severity:    domain.VulnSeverityLow,
				Confidence:  domain.ConfidenceLow,
				Evidence:    []string{"WPA3 SAE detected", "Cannot verify implementation quality"},
				DetectedAt:  time.Now(),
				Category:    "protocol",
				Description: "WPA3 SAE may be vulnerable if implementation is flawed",
				Mitigation:  "Ensure AP firmware is updated",
			})
		}
	}

	return tags
}

func (vd *VulnerabilityDetector) detectConfigurationVulnerabilities(device *domain.Device) []domain.VulnerabilityTag {
	tags := []domain.VulnerabilityTag{}

	// WPS Detection
	if device.WPSDetails != nil {
		wps := device.WPSDetails

		// WPS 1.0 - Vulnerable to Pixie Dust
		if wps.Version == "1.0" && !wps.Locked {
			tags = append(tags, domain.VulnerabilityTag{
				Name:        "WPS-PIXIE",
				Severity:    domain.VulnSeverityHigh,
				Confidence:  domain.ConfidenceHigh,
				Evidence:    []string{"WPS 1.0 detected", "WPS not locked"},
				DetectedAt:  time.Now(),
				Category:    "protocol",
				Description: "WPS 1.0 vulnerable to Pixie Dust offline attack",
				Mitigation:  "Disable WPS or upgrade to WPS 2.0 with proper implementation",
			})
		}

		// WPS Enabled (Generic)
		if wps.State == "Unconfigured" || containsString(wps.ConfigMethods, "PIN") {
			tags = append(tags, domain.VulnerabilityTag{
				Name:        "WPS-ENABLED",
				Severity:    domain.VulnSeverityMedium,
				Confidence:  domain.ConfidenceConfirmed,
				Evidence:    []string{fmt.Sprintf("WPS State: %s", wps.State)},
				DetectedAt:  time.Now(),
				Category:    "configuration",
				Description: "WPS PIN method enabled - vulnerable to brute force",
				Mitigation:  "Disable WPS or use PBC only",
			})
		}
	} else if device.WPSInfo != "" {
		// Fallback for legacy info
		tags = append(tags, domain.VulnerabilityTag{
			Name:        "WPS-ENABLED",
			Severity:    domain.VulnSeverityMedium,
			Confidence:  domain.ConfidenceMedium,
			Evidence:    []string{fmt.Sprintf("WPS Presence: %s", device.WPSInfo)},
			DetectedAt:  time.Now(),
			Category:    "configuration",
			Description: "WPS enabled - potential security risk",
			Mitigation:  "Disable WPS if not needed",
		})
	}

	return tags
}

func containsString(slice []string, val string) bool {
	for _, item := range slice {
		if item == val {
			return true
		}
	}
	return false
}
