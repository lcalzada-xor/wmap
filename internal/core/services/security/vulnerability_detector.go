package security

import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/lcalzada-xor/wmap/internal/core/domain"
	"github.com/lcalzada-xor/wmap/internal/core/ports"
)

// VulnerabilityDetector analyzes devices for security vulnerabilities (passive only)
type VulnerabilityDetector struct {
	registry   ports.DeviceRegistry
	vendorDB   *VendorDatabase
	cveMatcher ports.CVEMatcher
}

// NewVulnerabilityDetector creates a new vulnerability detector.
func NewVulnerabilityDetector(registry ports.DeviceRegistry) *VulnerabilityDetector {
	return &VulnerabilityDetector{
		registry: registry,
	}
}

// SetVendorDatabase injects the vendor database
func (vd *VulnerabilityDetector) SetVendorDatabase(vendorDB *VendorDatabase) {
	vd.vendorDB = vendorDB
}

// SetCVEMatcher injects the CVE matcher
func (vd *VulnerabilityDetector) SetCVEMatcher(matcher ports.CVEMatcher) {
	vd.cveMatcher = matcher
}

// DetectVulnerabilities performs passive vulnerability analysis on a device.
func (vd *VulnerabilityDetector) DetectVulnerabilities(device *domain.Device) []domain.VulnerabilityTag {
	tags := []domain.VulnerabilityTag{}

	// Type-specific detection
	if device.Type == domain.DeviceTypeAP {
		// AP-specific vulnerabilities
		tags = append(tags, vd.detectAPVulnerabilities(device)...)
	} else if device.Type == domain.DeviceTypeStation {
		// Client/Station-specific vulnerabilities
		tags = append(tags, detectClientVulnerabilities(device)...)
	}

	return tags
}

// detectAPVulnerabilities performs AP-specific vulnerability detection
func (vd *VulnerabilityDetector) detectAPVulnerabilities(device *domain.Device) []domain.VulnerabilityTag {
	tags := []domain.VulnerabilityTag{}

	// 1. Protocol-based detection
	tags = append(tags, vd.detectProtocolVulnerabilities(device)...)

	// 2. Configuration-based detection (legacy)
	tags = append(tags, vd.detectConfigurationVulnerabilities(device)...)

	// 3. Enhanced configuration detection (with vendor DB)
	if vd.vendorDB != nil {
		tags = append(tags, detectConfigurationVulnerabilitiesEnhanced(device, vd.vendorDB)...)
	}

	// 4. CVE Detection
	if vd.cveMatcher != nil {
		tags = append(tags, vd.detectCVEs(device)...)
	}

	return tags
}

// detectCVEs attempts to match device against CVE database
func (vd *VulnerabilityDetector) detectCVEs(device *domain.Device) []domain.VulnerabilityTag {
	if vd.cveMatcher == nil {
		return nil
	}

	ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
	defer cancel()

	matches, err := vd.cveMatcher.FindMatches(ctx, *device)
	if err != nil {
		// Log error but don't fail detection
		fmt.Printf("CVE matching failed: %v\n", err)
		return nil
	}

	var tags []domain.VulnerabilityTag
	for _, match := range matches {
		// Only report confident matches to reduce noise
		if match.Confidence < 0.7 {
			continue
		}

		tag := domain.VulnerabilityTag{
			Name:        match.CVE.ID,
			Severity:    mapCVSSToSeverity(match.CVE.Severity),
			Confidence:  domain.Confidence(match.Confidence),
			Evidence:    match.Evidence,
			DetectedAt:  time.Now(),
			Category:    "cve",
			Description: match.CVE.Description,
			Mitigation:  "Update firmware/software to latest version",
		}

		// Add references to mitigation if available
		if len(match.CVE.References) > 0 {
			tag.Mitigation += fmt.Sprintf(". See: %s", match.CVE.References[0])
		}

		tags = append(tags, tag)
	}

	return tags
}

func (vd *VulnerabilityDetector) detectProtocolVulnerabilities(device *domain.Device) []domain.VulnerabilityTag {
	tags := []domain.VulnerabilityTag{}

	// WEP Detection (Critical)
	if strings.Contains(strings.ToUpper(device.Security), "WEP") {
		tags = append(tags, domain.VulnerabilityTag{
			Name:        "WEP",
			Severity:    domain.VulnSeverityCritical,
			Confidence:  domain.ConfidenceConfirmed,
			Evidence:    []string{"WEP encryption detected in beacon/probe"},
			DetectedAt:  time.Now(),
			Category:    "protocol",
			Description: "WEP is fundamentally broken and can be cracked in minutes",
			Mitigation:  "Upgrade to WPA2-PSK (AES) or WPA3",
		})
	}

	// Additional protocol-specific logic
	if device.RSNInfo != nil {
		// 1. TKIP Detection (High - vulnerable to KRACK)
		if containsString(device.RSNInfo.PairwiseCiphers, "TKIP") {
			tags = append(tags, domain.VulnerabilityTag{
				Name:        "TKIP",
				Severity:    domain.VulnSeverityHigh,
				Confidence:  domain.ConfidenceConfirmed,
				Evidence:    []string{"TKIP cipher detected in RSN IE"},
				DetectedAt:  time.Now(),
				Category:    "protocol",
				Description: "TKIP is deprecated and vulnerable to key reinstallation attacks",
				Mitigation:  "Use CCMP (AES) cipher only",
			})
		}

		// 2. WPA2 without PMF (Medium - vulnerable to deauth attacks)
		if strings.Contains(device.Security, "WPA2") && !device.RSNInfo.Capabilities.MFPRequired {
			tags = append(tags, domain.VulnerabilityTag{
				Name:        "NO-PMF",
				Severity:    domain.VulnSeverityMedium,
				Confidence:  domain.ConfidenceConfirmed,
				Evidence:    []string{"PMF not required in RSN capabilities"},
				DetectedAt:  time.Now(),
				Category:    "configuration",
				Description: "Management frames unprotected - vulnerable to deauth attacks",
				Mitigation:  "Enable 802.11w (PMF) on AP",
			})
		}

		// 3. KRACK inference (Medium confidence)
		if strings.Contains(device.Security, "WPA2") {
			tags = append(tags, domain.VulnerabilityTag{
				Name:        "KRACK",
				Severity:    domain.VulnSeverityMedium,
				Confidence:  domain.ConfidenceMedium,
				Evidence:    []string{"WPA2 protocol detected", "No way to verify patch level passively"},
				DetectedAt:  time.Now(),
				Category:    "protocol",
				Description: "WPA2 vulnerable to key reinstallation if not patched",
				Mitigation:  "Ensure firmware is updated (post-2017)",
			})
		}

		// 4. WPA3 Transition Mode
		if device.Security == "WPA3" {
			hasPSK := containsString(device.RSNInfo.AKMSuites, "PSK")
			hasSAE := containsString(device.RSNInfo.AKMSuites, "SAE")
			if hasPSK && hasSAE {
				tags = append(tags, domain.VulnerabilityTag{
					Name:        "WPA3-TRANSITION",
					Severity:    domain.VulnSeverityLow,
					Confidence:  domain.ConfidenceConfirmed,
					Evidence:    []string{"Both PSK and SAE AKMs advertised"},
					DetectedAt:  time.Now(),
					Category:    "configuration",
					Description: "WPA3 transition mode allows downgrade to WPA2",
					Mitigation:  "Use WPA3-only mode when all clients support it",
				})
			}

			// Dragonblood inference
			tags = append(tags, domain.VulnerabilityTag{
				Name:        "DRAGONBLOOD",
				Severity:    domain.VulnSeverityLow,
				Confidence:  domain.ConfidenceLow,
				Evidence:    []string{"WPA3 SAE detected", "Cannot verify implementation quality"},
				DetectedAt:  time.Now(),
				Category:    "protocol",
				Description: "WPA3 SAE may be vulnerable if implementation is flawed",
				Mitigation:  "Ensure AP firmware is updated",
			})
		}

		// 5. Fast Roaming (802.11r) Analysis
		if device.MobilityDomain != nil {
			// Check for FT-PSK (AKM 4)
			if containsString(device.RSNInfo.AKMSuites, "FT-PSK") {
				tags = append(tags, domain.VulnerabilityTag{
					Name:        "FT-PSK",
					Severity:    domain.VulnSeverityLow,
					Confidence:  domain.ConfidenceConfirmed,
					Evidence:    []string{"802.11r Fast Transition compliant", "FT-PSK AKM detected"},
					DetectedAt:  time.Now(),
					Category:    "configuration",
					Description: "Fast Transition with PSK allows for wider attack surface if PSK is weak",
					Mitigation:  "Use strong, long PSK or switch to 802.1X",
				})
			}

			// Check for FT over DS (Distributed System)
			if device.MobilityDomain.OverDS {
				tags = append(tags, domain.VulnerabilityTag{
					Name:        "FT-OVER-DS",
					Severity:    domain.VulnSeverityInfo,
					Confidence:  domain.ConfidenceConfirmed,
					Evidence:    []string{"FT over DS allowed in Mobility Domain IE"},
					DetectedAt:  time.Now(),
					Category:    "configuration",
					Description: "Fast Transition over DS enabled - verify DS security",
					Mitigation:  "Ensure wired backhaul is secure",
				})
			}
		}
	}

	return tags
}

func (vd *VulnerabilityDetector) detectConfigurationVulnerabilities(device *domain.Device) []domain.VulnerabilityTag {
	tags := []domain.VulnerabilityTag{}

	// WPS Detection
	if device.WPSDetails != nil {
		wps := device.WPSDetails

		// WPS 1.0 - Vulnerable to Pixie Dust
		if wps.Version == "1.0" && !wps.Locked {
			tags = append(tags, domain.VulnerabilityTag{
				Name:        "WPS-PIXIE",
				Severity:    domain.VulnSeverityHigh,
				Confidence:  domain.ConfidenceHigh,
				Evidence:    []string{"WPS 1.0 detected", "WPS not locked"},
				DetectedAt:  time.Now(),
				Category:    "protocol",
				Description: "WPS 1.0 vulnerable to Pixie Dust offline attack",
				Mitigation:  "Disable WPS or upgrade to WPS 2.0 with proper implementation",
			})
		}

		// WPS Enabled (Generic)
		if wps.State == "Unconfigured" || containsString(wps.ConfigMethods, "PIN") {
			tags = append(tags, domain.VulnerabilityTag{
				Name:        "WPS-ENABLED",
				Severity:    domain.VulnSeverityMedium,
				Confidence:  domain.ConfidenceConfirmed,
				Evidence:    []string{fmt.Sprintf("WPS State: %s", wps.State)},
				DetectedAt:  time.Now(),
				Category:    "configuration",
				Description: "WPS PIN method enabled - vulnerable to brute force",
				Mitigation:  "Disable WPS or use PBC only",
			})
		}
	} else if device.WPSInfo != "" {
		// Fallback for legacy info
		tags = append(tags, domain.VulnerabilityTag{
			Name:        "WPS-ENABLED",
			Severity:    domain.VulnSeverityMedium,
			Confidence:  domain.ConfidenceMedium,
			Evidence:    []string{fmt.Sprintf("WPS Presence: %s", device.WPSInfo)},
			DetectedAt:  time.Now(),
			Category:    "configuration",
			Description: "WPS enabled - potential security risk",
			Mitigation:  "Disable WPS if not needed",
		})
	}

	return tags
}

func containsString(slice []string, val string) bool {
	for _, item := range slice {
		if item == val {
			return true
		}
	}
	return false
}

// mapCVSSToSeverity maps CVSS score (0-10) to domain.Severity
func mapCVSSToSeverity(score float64) domain.Severity {
	switch {
	case score >= 9.0:
		return domain.VulnSeverityCritical
	case score >= 7.0:
		return domain.VulnSeverityHigh
	case score >= 4.0:
		return domain.VulnSeverityMedium
	case score >= 0.1:
		return domain.VulnSeverityLow
	default:
		return domain.VulnSeverityInfo
	}
}
