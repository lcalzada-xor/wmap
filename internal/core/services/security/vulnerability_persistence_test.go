package security

import (
	"context"
	"errors"
	"testing"
	"time"

	"github.com/lcalzada-xor/wmap/internal/core/domain"
	//"github.com/lcalzada-xor/wmap/internal/core/ports"
)

// MockStorage for testing
type MockStorage struct {
	SaveVulnerabilityFunc  func(ctx context.Context, record domain.VulnerabilityRecord) error
	GetVulnerabilitiesFunc func(ctx context.Context, filter domain.VulnerabilityFilter) ([]domain.VulnerabilityRecord, error)
	GetVulnerabilityFunc   func(ctx context.Context, id string) (*domain.VulnerabilityRecord, error)
	UpdateStatusFunc       func(ctx context.Context, id string, status domain.VulnerabilityStatus, notes string) error

	// unused methods for interface compliance
	SaveDeviceFunc func(ctx context.Context, device domain.Device) error
}

func (m *MockStorage) SaveVulnerability(ctx context.Context, record domain.VulnerabilityRecord) error {
	if m.SaveVulnerabilityFunc != nil {
		return m.SaveVulnerabilityFunc(ctx, record)
	}
	return nil
}

func (m *MockStorage) GetVulnerabilities(ctx context.Context, filter domain.VulnerabilityFilter) ([]domain.VulnerabilityRecord, error) {
	if m.GetVulnerabilitiesFunc != nil {
		return m.GetVulnerabilitiesFunc(ctx, filter)
	}
	return nil, nil
}

func (m *MockStorage) GetVulnerability(ctx context.Context, id string) (*domain.VulnerabilityRecord, error) {
	if m.GetVulnerabilityFunc != nil {
		return m.GetVulnerabilityFunc(ctx, id)
	}
	return nil, errors.New("not found")
}

func (m *MockStorage) UpdateVulnerabilityStatus(ctx context.Context, id string, status domain.VulnerabilityStatus, notes string) error {
	if m.UpdateStatusFunc != nil {
		return m.UpdateStatusFunc(ctx, id, status, notes)
	}
	return nil
}

// Satisfy Full Storage Interface stubbing (minimal)
func (m *MockStorage) SaveDevice(ctx context.Context, d domain.Device) error         { return nil }
func (m *MockStorage) SaveDevicesBatch(ctx context.Context, d []domain.Device) error { return nil }
func (m *MockStorage) GetDevice(ctx context.Context, mac string) (*domain.Device, error) {
	return nil, nil
}
func (m *MockStorage) GetAllDevices(ctx context.Context) ([]domain.Device, error) { return nil, nil }
func (m *MockStorage) SaveProbe(ctx context.Context, mac, ssid string) error      { return nil }
func (m *MockStorage) Close() error                                               { return nil }

// MockNotifier
type MockNotifier struct {
	NotifyFunc func(ctx context.Context, vuln domain.VulnerabilityRecord)
	Notified   bool
}

func (m *MockNotifier) NotifyNewVulnerability(ctx context.Context, vuln domain.VulnerabilityRecord) {
	m.Notified = true
	if m.NotifyFunc != nil {
		m.NotifyFunc(ctx, vuln)
	}
}

func TestProcessDetections_NewVulnerability_ShouldNotify(t *testing.T) {
	// Arrange
	mockStorage := &MockStorage{}
	// Mock that GetVulnerability returns "not found" (error) for unique ID check
	mockStorage.GetVulnerabilityFunc = func(ctx context.Context, id string) (*domain.VulnerabilityRecord, error) {
		return nil, errors.New("not found")
	}

	mockNotifier := &MockNotifier{}

	service := NewVulnerabilityPersistenceService(mockStorage)
	service.SetNotifier(mockNotifier)

	vuln := domain.VulnerabilityTag{
		Name:       "Weak WEP",
		Severity:   9,
		Category:   "encryption",
		DetectedAt: time.Now(),
	}

	// Act
	err := service.ProcessDetections("AA:BB:CC:DD:EE:FF", []domain.VulnerabilityTag{vuln})

	// Assert
	if err != nil {
		t.Fatalf("Expected no error, got %v", err)
	}

	if !mockNotifier.Notified {
		t.Error("Expected notification to be sent for new vulnerability, but it was not")
	}
}

func TestProcessDetections_ExistingVulnerability_ShouldNotNotify(t *testing.T) {
	// Arrange
	mockStorage := &MockStorage{}
	// Mock that GetVulnerability returns existing record
	mockStorage.GetVulnerabilityFunc = func(ctx context.Context, id string) (*domain.VulnerabilityRecord, error) {
		return &domain.VulnerabilityRecord{ID: id}, nil
	}

	mockNotifier := &MockNotifier{}

	service := NewVulnerabilityPersistenceService(mockStorage)
	service.SetNotifier(mockNotifier)

	vuln := domain.VulnerabilityTag{
		Name:     "Weak WEP",
		Severity: 9,
		Category: "encryption",
	}

	// Act
	// We expect NO notification because it exists
	err := service.ProcessDetections("AA:BB:CC:DD:EE:FF", []domain.VulnerabilityTag{vuln})

	// Assert
	if err != nil {
		t.Fatalf("Expected no error, got %v", err)
	}

	if mockNotifier.Notified {
		t.Error("Expected NO notification for existing vulnerability, but one was sent")
	}
}

func TestUpdateStatus_ShouldPassNotes(t *testing.T) {
	// Arrange
	mockStorage := &MockStorage{}
	var capturedNotes string
	var capturedStatus domain.VulnerabilityStatus

	mockStorage.UpdateStatusFunc = func(ctx context.Context, id string, status domain.VulnerabilityStatus, notes string) error {
		capturedStatus = status
		capturedNotes = notes
		return nil
	}

	service := NewVulnerabilityPersistenceService(mockStorage)

	// Act
	err := service.UpdateStatus("vuln-1", domain.VulnStatusIgnored, "False positive")

	// Assert
	if err != nil {
		t.Fatalf("Expected no error, got %v", err)
	}

	if capturedStatus != domain.VulnStatusIgnored {
		t.Errorf("Expected status %v, got %v", domain.VulnStatusIgnored, capturedStatus)
	}
	if capturedNotes != "False positive" {
		t.Errorf("Expected notes 'False positive', got '%s'", capturedNotes)
	}
}
