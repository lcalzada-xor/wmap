package security

import (
	"context"
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"time"

	"github.com/lcalzada-xor/wmap/internal/core/domain"
	"github.com/lcalzada-xor/wmap/internal/core/ports"
)

// VulnerabilityPersistenceService handles storage and retrieval of vulnerabilities.
type VulnerabilityPersistenceService struct {
	storage  ports.Storage
	notifier ports.VulnerabilityNotifier
}

// NewVulnerabilityPersistenceService creates a new service instance.
func NewVulnerabilityPersistenceService(storage ports.Storage) *VulnerabilityPersistenceService {
	return &VulnerabilityPersistenceService{
		storage: storage,
	}
}

// SetNotifier sets the vulnerability notifier.
func (s *VulnerabilityPersistenceService) SetNotifier(notifier ports.VulnerabilityNotifier) {
	s.notifier = notifier
}

// GenerateID creates a deterministic ID for a vulnerability.
func (s *VulnerabilityPersistenceService) GenerateID(vuln domain.VulnerabilityTag, mac string) string {
	raw := fmt.Sprintf("%s|%s|%s", mac, vuln.Name, vuln.Category)
	hash := sha256.Sum256([]byte(raw))
	return hex.EncodeToString(hash[:])
}

// ProcessDetections saves new detections and updates existing ones.
func (s *VulnerabilityPersistenceService) ProcessDetections(mac string, vulns []domain.VulnerabilityTag) error {
	ctx := context.Background()
	fmt.Printf("[VULN-PERSIST] Processing %d vulnerabilities for device %s\n", len(vulns), mac)

	for _, v := range vulns {
		id := s.GenerateID(v, mac)
		record := domain.VulnerabilityRecord{
			ID:          id,
			DeviceMAC:   mac,
			Name:        v.Name,
			Severity:    v.Severity,
			Confidence:  v.Confidence,
			FirstSeen:   v.DetectedAt,
			LastSeen:    time.Now(),
			Status:      domain.VulnStatusActive,
			Evidence:    v.Evidence,
			Description: v.Description,
		}

		// Check if exists to determine if we should notify
		_, err := s.storage.GetVulnerability(ctx, id)
		isNew := err != nil

		if isNew {
			fmt.Printf("[VULN-PERSIST] New vulnerability: %s (severity=%d) for device %s\n", v.Name, v.Severity, mac)
			if s.notifier != nil {
				s.notifier.NotifyNewVulnerability(ctx, record)
			}
		}

		if err := s.storage.SaveVulnerability(ctx, record); err != nil {
			fmt.Printf("[VULN-PERSIST] Error saving vulnerability %s: %v\n", v.Name, err)
			return err
		}
	}
	fmt.Printf("[VULN-PERSIST] Successfully persisted %d vulnerabilities for device %s\n", len(vulns), mac)
	return nil
}

// GetVulnerabilities returns list of vulnerabilities filtered by criteria.
func (s *VulnerabilityPersistenceService) GetVulnerabilities(filter domain.VulnerabilityFilter) ([]domain.VulnerabilityRecord, error) {
	return s.storage.GetVulnerabilities(context.Background(), filter)
}

// UpdateStatus updates the status of a vulnerability (e.g., ignore, fix).
func (s *VulnerabilityPersistenceService) UpdateStatus(id string, status domain.VulnerabilityStatus, notes string) error {
	return s.storage.UpdateVulnerabilityStatus(context.Background(), id, status, notes)
}

// ConfirmVulnerability updates a vulnerability record when confirmed via active attack
func (s *VulnerabilityPersistenceService) ConfirmVulnerability(ctx context.Context, confirmation domain.VulnerabilityConfirmation) error {
	fmt.Printf("[VULN-CONFIRM] Confirming vulnerability %s for device %s via %s\n",
		confirmation.VulnerabilityName, confirmation.DeviceMAC, confirmation.ConfirmedBy)

	// Generate ID using the same logic as detection
	// We need to find the vulnerability by name and MAC
	filter := domain.VulnerabilityFilter{
		DeviceMAC: confirmation.DeviceMAC,
	}

	vulnerabilities, err := s.storage.GetVulnerabilities(ctx, filter)
	if err != nil {
		return fmt.Errorf("failed to retrieve vulnerabilities for confirmation: %w", err)
	}

	// Find the matching vulnerability
	var targetVuln *domain.VulnerabilityRecord
	for i := range vulnerabilities {
		if vulnerabilities[i].Name == confirmation.VulnerabilityName {
			targetVuln = &vulnerabilities[i]
			break
		}
	}

	if targetVuln == nil {
		// Vulnerability doesn't exist yet - this shouldn't happen but we'll handle it gracefully
		fmt.Printf("[VULN-CONFIRM] Warning: Vulnerability %s not found for device %s, skipping confirmation\n",
			confirmation.VulnerabilityName, confirmation.DeviceMAC)
		return fmt.Errorf("vulnerability %s not found for device %s", confirmation.VulnerabilityName, confirmation.DeviceMAC)
	}

	// Update the vulnerability with confirmation details
	targetVuln.ConfirmWithEvidence(confirmation)

	// Save the updated vulnerability
	if err := s.storage.SaveVulnerability(ctx, *targetVuln); err != nil {
		fmt.Printf("[VULN-CONFIRM] Error saving confirmed vulnerability %s: %v\n", confirmation.VulnerabilityName, err)
		return fmt.Errorf("failed to save confirmed vulnerability: %w", err)
	}

	fmt.Printf("[VULN-CONFIRM] Successfully confirmed %s for device %s (confidence now 1.0)\n",
		confirmation.VulnerabilityName, confirmation.DeviceMAC)

	// Notify observers if notifier is set
	if s.notifier != nil {
		s.notifier.NotifyVulnerabilityConfirmed(ctx, *targetVuln)
	}

	return nil
}
