package security

import (
	"context"
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"time"

	"github.com/lcalzada-xor/wmap/internal/core/domain"
	"github.com/lcalzada-xor/wmap/internal/core/ports"
)

// VulnerabilityPersistenceService handles storage and retrieval of vulnerabilities.
type VulnerabilityPersistenceService struct {
	storage  ports.Storage
	notifier ports.VulnerabilityNotifier
}

// NewVulnerabilityPersistenceService creates a new service instance.
func NewVulnerabilityPersistenceService(storage ports.Storage) *VulnerabilityPersistenceService {
	return &VulnerabilityPersistenceService{
		storage: storage,
	}
}

// SetNotifier sets the vulnerability notifier.
func (s *VulnerabilityPersistenceService) SetNotifier(notifier ports.VulnerabilityNotifier) {
	s.notifier = notifier
}

// GenerateID creates a deterministic ID for a vulnerability.
func (s *VulnerabilityPersistenceService) GenerateID(vuln domain.VulnerabilityTag, mac string) string {
	raw := fmt.Sprintf("%s|%s|%s", mac, vuln.Name, vuln.Category)
	hash := sha256.Sum256([]byte(raw))
	return hex.EncodeToString(hash[:])
}

// ProcessDetections saves new detections and updates existing ones.
func (s *VulnerabilityPersistenceService) ProcessDetections(mac string, vulns []domain.VulnerabilityTag) error {
	ctx := context.Background()
	for _, v := range vulns {
		id := s.GenerateID(v, mac)
		record := domain.VulnerabilityRecord{
			ID:          id,
			DeviceMAC:   mac,
			Name:        v.Name,
			Severity:    v.Severity,
			Confidence:  v.Confidence,
			FirstSeen:   v.DetectedAt,
			LastSeen:    time.Now(),
			Status:      domain.VulnStatusActive,
			Evidence:    v.Evidence,
			Description: v.Description,
		}

		// Check if exists to determine if we should notify
		_, err := s.storage.GetVulnerability(ctx, id)
		isNew := err != nil

		if isNew && s.notifier != nil {
			s.notifier.NotifyNewVulnerability(ctx, record)
		}

		if err := s.storage.SaveVulnerability(ctx, record); err != nil {
			return err
		}
	}
	return nil
}

// GetVulnerabilities returns list of vulnerabilities filtered by criteria.
func (s *VulnerabilityPersistenceService) GetVulnerabilities(filter domain.VulnerabilityFilter) ([]domain.VulnerabilityRecord, error) {
	return s.storage.GetVulnerabilities(context.Background(), filter)
}

// UpdateStatus updates the status of a vulnerability (e.g., ignore, fix).
func (s *VulnerabilityPersistenceService) UpdateStatus(id string, status domain.VulnerabilityStatus, notes string) error {
	return s.storage.UpdateVulnerabilityStatus(context.Background(), id, status, notes)
}
